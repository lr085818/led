<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LED大屏模组组装工具</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=JetBrains+Mono:wght@100;200;400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/@pdf-lib/fontkit@0.0.4/dist/fontkit.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>
    <style>
        body {
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #0d1b0a 0%, #0a0f09 30%, #152713 70%, #000000 100%);
            color: #ffffff;
            font-family: 'Space Grotesk', 'JetBrains Mono', sans-serif;
            transition: background 0.5s ease;
        }
        .container {
            width: 100%;
            max-width: 1200px;
            background: rgba(23, 23, 23, 0.9);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 8px 32px 0 rgba(118, 185, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(118, 185, 0, 0.15);
            transition: all 0.3s ease;
        }
        .container:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px 0 rgba(31, 38, 135, 0.55);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        h1 {
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 700;
            letter-spacing: 1px;
            background: linear-gradient(135deg, #76b900 0%, #000000 30%, #76b900 70%, #000000 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 10px rgba(118, 185, 0, 0.3);
        }

        .header-logo {
            position: absolute;
            top: 15px;
            right: 15px;
            height: 30px;
            width: auto;
            z-index: 1000;
            filter: drop-shadow(0 2px 4px rgba(118, 185, 0, 0.3));
            transition: all 0.3s ease;
            transform-origin: right top;
        }
        #canvasContainer {
            border: 1px solid #76b900;
            margin-top: 25px;
            overflow: hidden;
            height: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 500px;
            width: 100%;
            background: 
                linear-gradient(135deg, 
                    rgba(118, 185, 0, 0.15) 0%, 
                    rgba(18, 28, 8, 0.9) 50%,
                    rgba(118, 185, 0, 0.15) 100%),
                radial-gradient(circle at 50% 50%, 
                    rgba(118, 185, 0, 0.1) 0%, 
                    rgba(11, 18, 5, 0.9) 70%);
            border-radius: 20px;
            position: relative;
            backdrop-filter: blur(8px);
            box-shadow: 0 8px 32px rgba(118, 185, 0, 0.3);
            transition: all 0.3s ease;
        }
        #canvasContainer:hover {
            border-color: rgba(255, 255, 255, 0.25);
            box-shadow: 0 12px 40px rgba(31, 38, 135, 0.3);
            transform: translateY(-2px);
        }
        #ledCanvas {
            background: rgba(23, 35, 15, 0.6);
            display: block;
            box-shadow: inset 0 0 30px rgba(118, 185, 0, 0.2);
        }
        .control-panel {
            margin-bottom: 20px;
        }
        .form-control, .form-select {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 400;
            letter-spacing: 0.5px;
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #ffffff;
            cursor: pointer;
            padding: 10px 15px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        .form-control:hover, .form-select:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.25);
            transform: translateY(-1px);
        }
        .form-control:focus, .form-select:focus {
            background: rgba(46, 204, 113, 0.15);
            color: #ffffff;
            border-color: #76b900;
            box-shadow: 0 0 0 0.2rem rgba(118, 185, 0, 0.25);
        }
        .form-control.active, .form-select.active {
            background: rgba(46, 204, 113, 0.15);
            border-color: rgba(46, 204, 113, 0.4);
        }
        .form-select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='%2300ffde' stroke='%2300ffde' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M2 5l6 6 6-6'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 16px 12px;
            padding-right: 2.5rem;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
        }
        .form-select:hover {
            cursor: pointer;
            background-color: rgba(0, 255, 222, 0.1);
        }
        .custom-file-upload {
            display: inline-block;
            padding: 6px 12px;
            cursor: pointer;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            transition: all 0.3s ease;
            color: #ffffff;
        }
        .custom-file-upload:hover {
            background-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        .custom-file-upload.active {
            background-color: rgba(0, 255, 222, 0.15);
            border-color: rgba(46, 204, 113, 0.4);
        }
        #imagePreviewStatus {
            margin-top: 10px;
            font-size: 0.9em;
        }
        .mode-panel {
            margin-bottom: 15px;
        }
        .mode-panel .btn {
            font-family: 'Space Grotesk', sans-serif;
            margin-right: 10px;
            padding: 12px 20px;
            font-weight: 600;
            font-size: 1.1rem;
            letter-spacing: 0.5px;
            border-radius: 12px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: #ffffff;
            background-color: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.15);
            position: relative;
            overflow: hidden;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(4px);
        }
        .mode-panel .btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 50%;
            transform: scale(1, 1) translate(-50%, -50%);
            transform-origin: 50% 50%;
        }
        .mode-panel .btn:focus:not(.active)::after {
            animation: ripple 0.6s ease-out;
        }
        .mode-panel .btn.active {
            background-color: #76b900;
            color: #ffffff;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(118, 185, 0, 0.6);
            border: 1px solid #76b900;
        }
        .mode-panel .btn:hover:not(.active) {
            background-color: rgba(255, 255, 255, 0.25);
            transform: scale(1.02);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }
        @keyframes ripple {
            0% {
                transform: scale(0, 0);
                opacity: 0.5;
            }
            20% {
                transform: scale(25, 25);
                opacity: 0.3;
            }
            100% {
                opacity: 0;
                transform: scale(40, 40);
            }
        }
        .input-group {
            margin-bottom: 10px;
        }
        .btn-primary {
            background: linear-gradient(135deg, #76b900, #a3d43d);
            border: none;
            transition: all 0.3s ease;
            padding: 12px 24px;
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 600;
            letter-spacing: 0.5px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(118, 185, 0, 0.2);
        }
        .btn-secondary {
            padding: 12px 24px;
            font-size: 1.1rem;
            line-height: 1.5;
            min-width: 120px;
            height: 48px;  /* 确保与生成布局按钮高度一致 */
            border-radius: 12px;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 600;
            letter-spacing: 0.5px;
            margin-top: -1px;  /* 微调垂直对齐 */
        }
        .btn-outline-success {
            padding: 12px 24px;
            font-size: 1.1rem;
            border-radius: 12px;
            transition: all 0.3s ease;
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 600;
            letter-spacing: 0.5px;
            border: 1px solid #76b900;
            color: #a3d43d;
            background: linear-gradient(135deg, rgba(118, 185, 0, 0.15), rgba(163, 212, 61, 0.15));
            box-shadow: 0 0 0 0.2rem rgba(118, 185, 0, 0.25);
        }

        .btn-outline-success:hover {
            border-color: #a3d43d;
            color: #76b900;
            background: linear-gradient(135deg, rgba(118, 185, 0, 0.25), rgba(163, 212, 61, 0.25));
        }

        .btn-outline-secondary {
            padding: 12px 24px;
            font-size: 1.1rem;
            border-radius: 12px;
            transition: all 0.3s ease;
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .btn-success {
            background: linear-gradient(135deg, #76b900, #a3d43d);
            border: none;
            box-shadow: 0 4px 15px rgba(118, 185, 0, 0.2);
            padding: 12px 24px;
            font-size: 1.1rem;
            border-radius: 12px;
            transition: all 0.3s ease;
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .btn-success:hover {
            background: linear-gradient(135deg, #5e9400, #8ab82e);
            box-shadow: 0 6px 20px rgba(118, 185, 0, 0.4);
        }
        .btn-primary:hover {
            background: linear-gradient(135deg, #5e9400, #8ab82e);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(118, 185, 0, 0.4);
        }
        .btn-primary:disabled {
            background-color: rgba(52, 152, 219, 0.5);
            cursor: not-allowed;
        }
        .form-select option {
            background-color: rgba(13, 27, 42, 0.9);
            color: #ffffff;
        }
        .dimension-highlight {
            font-size: 1.1em;
            color: #ff6b6b;
            text-shadow: 0 0 5px rgba(255, 107, 107, 0.5);
            font-weight: 700;
        }
        .alert-info {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }
        .export-panel {
            background: rgba(23, 23, 23, 0.85);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(118, 185, 0, 0.2);
            backdrop-filter: blur(8px);
            transition: all 0.3s ease;
        }
        .export-panel:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }
        .export-panel .btn {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: 500;
            letter-spacing: 0.5px;
            backdrop-filter: blur(4px);
        }
        .export-panel .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(255, 255, 255, 0.25);
            background-color: rgba(255, 255, 255, 0.15);
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="logo.png" alt="Logo" class="header-logo">
        <h1 class="text-center mb-4">LED大屏模组组装工具</h1>
        <div class="control-panel">
            <div class="row">
                <div class="col-md-3">
                    <label for="pixelPitch" class="form-label">LED点间距 (mm):</label>
                    <select id="pixelPitch" class="form-select">
                        <option value="1.25">P1.25</option>
                        <option value="1.53">P1.53</option>
                        <option value="1.66">P1.66</option>
                        <option value="1.8">P1.8</option>
                        <option value="2">P2</option>
                        <option value="2.5">P2.5</option>
                        <option value="3">P3</option>
                        <option value="4">P4</option>
                    </select>
                </div>
                <div class="col-md-3">
                    <label for="moduleSize" class="form-label">模组尺寸 (mm):</label>
                    <select id="moduleSize" class="form-select">
                        <option value="300x337.5">300 x 337.5</option>
                        <option value="320x160">320 x 160</option>
                        <option value="304x168.5">304 x 168.5</option>
                        <option value="256x128">256 x 128</option>
                        <option value="192x192">192 x 192</option>
                    </select>
                </div>
                <div class="col-md-6 d-flex align-items-end gap-2">
                    <button id="generateBtn" class="btn btn-primary flex-grow-1">生成布局</button>
                    <button id="resetBtn" class="btn btn-secondary flex-grow-1">重置</button>
                </div>
            </div>
            <div class="row mt-3 mode-panel">
                <div class="col-md-12">
                    <label class="form-label">计算模式:</label>
                    <div class="btn-group" role="group">
                        <button type="button" class="btn active" data-mode="manual">预览模式</button>
                        <button type="button" class="btn" data-mode="dimension">自定义模式</button>
                        <button type="button" class="btn" data-mode="ratio">计算比例</button>
                    </div>
                </div>
            </div>
            <div id="manualInput" class="row input-group">
                <div class="col-md-2">
                    <label for="rows" class="form-label">行数:</label>
                    <input type="number" id="rows" class="form-control" value="2" min="1" placeholder="请输入行数">
                </div>
                <div class="col-md-2">
                    <label for="cols" class="form-label">列数:</label>
                    <input type="number" id="cols" class="form-control" value="2" min="1" placeholder="请输入列数">
                </div>
            </div>
            <div id="dimensionInput" class="row input-group" style="display: none;">
                <div class="col-md-3">
                    <label for="totalWidth" class="form-label">宽度 (m):</label>
                    <input type="number" id="totalWidth" class="form-control" step="0.1" min="0.1" value="0" placeholder="请输入宽度 (m)">
                </div>
                <div class="col-md-3">
                    <label for="totalHeight" class="form-label">高度 (m):</label>
                    <input type="number" id="totalHeight" class="form-control" step="0.1" min="0.1" value="0" placeholder="请输入高度 (m)">
                </div>
                <div class="col-md-3">
                    <label for="aspectRatio" class="form-label">宽高比 (宽度:高度):</label>
                    <select id="aspectRatio" class="form-select">
                        <option value="16:9" selected>16:9 (常见宽屏)</option>
                        <option value="4:3">4:3 (传统显示)</option>
                        <option value="16:10">16:10 (笔记本常见)</option>
                        <option value="21:9">21:9 (超宽屏)</option>
                    </select>
                </div>
            </div>
            <div id="ratioInput" class="row input-group" style="display: none;">
                <div class="col-md-3">
                    <label for="ratioWidth" class="form-label">宽度 (m):</label>
                    <input type="number" id="ratioWidth" class="form-control" step="0.1" min="0.1" value="0" placeholder="请输入宽度 (m)">
                </div>
                <div class="col-md-3">
                    <label for="ratioHeight" class="form-label">高度 (m):</label>
                    <input type="number" id="ratioHeight" class="form-control" step="0.1" min="0.1" value="0" placeholder="请输入高度 (m)">
                </div>
            </div>
            <div class="row mt-3">
                <div class="col-md-12 d-flex align-items-center gap-3">
                    <label for="imageUpload" class="custom-file-upload btn btn-success">
                        <i class="fas fa-upload me-2"></i>选择图片
                    </label>
                    <button id="toggleImageBtn" class="btn btn-outline-success" disabled>
                        <i class="fas fa-image me-2"></i>显示图片预览
                    </button>
                    <button id="clearImageBtn" class="btn btn-outline-secondary" disabled>
                        <i class="fas fa-trash me-2"></i>清除图片
                    </button>
                    <span id="imagePreviewStatus" class="text-light ms-2">未选择图片</span>
                    <input id="imageUpload" type="file" accept="image/*" style="display: none;">
                </div>
            </div>
            <div class="row mt-3">
                <div class="col-12">
                    <div class="export-panel">
                        <label class="form-label me-2">导出结果:</label>
                        <button id="exportPDF" class="btn btn-outline-light me-2">
                            <i class="fas fa-file-pdf me-1"></i>PDF
                        </button>
                        <button id="exportExcel" class="btn btn-outline-light">
                            <i class="fas fa-file-excel me-1"></i>Excel
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <div class="alert alert-info" id="dimensionInfo">
            大屏数据将会显示在这里
        </div>
        <div id="canvasContainer">
            <canvas id="ledCanvas"></canvas>
        </div>
    </div>

    <script>
        // 全局变量和初始化
        const App = (function() {
            // DOM 元素
            const elements = {
                canvas: document.getElementById('ledCanvas'),
                dimensionInfo: document.getElementById('dimensionInfo'),
                generateBtn: document.getElementById('generateBtn'),
                resetBtn: document.getElementById('resetBtn'),
                canvasContainer: document.getElementById('canvasContainer'),
                pixelPitchSelect: document.getElementById('pixelPitch'),
                moduleSizeSelect: document.getElementById('moduleSize'),
                rowsInput: document.getElementById('rows'),
                colsInput: document.getElementById('cols'),
                modeButtons: document.querySelectorAll('.mode-panel .btn'),
                aspectRatioSelect: document.getElementById('aspectRatio'),
                totalWidthInput: document.getElementById('totalWidth'),
                totalHeightInput: document.getElementById('totalHeight'),
                imageUpload: document.getElementById('imageUpload'),
                imagePreviewStatus: document.getElementById('imagePreviewStatus'),
                toggleImageBtn: document.getElementById('toggleImageBtn'),
                clearImageBtn: document.getElementById('clearImageBtn'),
                ratioWidthInput: document.getElementById('ratioWidth'),
                ratioHeightInput: document.getElementById('ratioHeight')
            };

            const exportElements = {
                pdfBtn: document.getElementById('exportPDF'),
                excelBtn: document.getElementById('exportExcel')
            };

            const ctx = elements.canvas.getContext('2d');
            let isInitialState = true;
            let currentMode = 'manual';
            let uploadedImage = null;
            let isImageVisible = false;

            // 初始化函数
            function init() {
                loadSavedConfig();
                setupEventListeners();
                setupDimensionLinkage();
                setupExportListeners();
                resizeCanvas(800, 500);
                drawWelcomeScreen();
                const initEvent = new Event('change');
                elements.pixelPitchSelect.dispatchEvent(initEvent);
            }

            // 加载保存的配置
            function loadSavedConfig() {
                const savedConfig = JSON.parse(localStorage.getItem('ledScreenConfig'));
                if (savedConfig) {
                    elements.pixelPitchSelect.value = savedConfig.pixelPitch || '1.25';
                    elements.moduleSizeSelect.value = savedConfig.moduleSize || '320x160';
                    elements.rowsInput.value = savedConfig.rows || 2;
                    elements.colsInput.value = savedConfig.cols || 2;
                    elements.totalWidthInput.value = savedConfig.totalWidth || 0;
                    elements.totalHeightInput.value = savedConfig.totalHeight || 0;
                    elements.aspectRatioSelect.value = savedConfig.aspectRatio || '16:9';
                    currentMode = savedConfig.mode || 'manual';
                    elements.modeButtons.forEach(btn => btn.classList.remove('active'));
                    document.querySelector(`[data-mode="${currentMode}"]`).classList.add('active');
                    document.querySelectorAll('.input-group').forEach(group => group.style.display = 'none');
                    document.getElementById(currentMode + 'Input').style.display = 'flex';
                }
            }

            // 保存配置到本地存储
            function saveConfig() {
                const config = {
                    pixelPitch: elements.pixelPitchSelect.value,
                    moduleSize: elements.moduleSizeSelect.value,
                    rows: elements.rowsInput.value,
                    cols: elements.colsInput.value,
                    totalWidth: elements.totalWidthInput.value,
                    totalHeight: elements.totalHeightInput.value,
                    aspectRatio: elements.aspectRatioSelect.value,
                    mode: currentMode
                };
                localStorage.setItem('ledScreenConfig', JSON.stringify(config));
            }

            // 设置事件监听
            function setupEventListeners() {
                elements.pixelPitchSelect.addEventListener('change', updateModuleSizeOptions);
                [elements.rowsInput, elements.colsInput, elements.pixelPitchSelect, elements.moduleSizeSelect, elements.aspectRatioSelect, elements.totalWidthInput, elements.totalHeightInput, elements.ratioWidthInput, elements.ratioHeightInput].forEach(input => {
                    input.addEventListener('change', () => elements.generateBtn.disabled = false);
                    input.addEventListener('input', () => elements.generateBtn.disabled = false);
                });
                elements.modeButtons.forEach(button => button.addEventListener('click', switchMode));
                elements.generateBtn.addEventListener('click', generateLayout);
                elements.resetBtn.addEventListener('click', resetCanvas);
                elements.imageUpload.addEventListener('change', handleImageUpload);
                elements.toggleImageBtn.addEventListener('click', toggleImageVisibility);
                elements.clearImageBtn.addEventListener('click', clearImage);

                // 添加输入框激活状态处理
                [elements.totalWidthInput, elements.totalHeightInput].forEach(input => {
                    input.addEventListener('focus', () => input.classList.add('active'));
                    input.addEventListener('blur', () => {
                        if (!input.value) input.classList.remove('active');
                    });
                    input.addEventListener('input', () => {
                        if (input.value) {
                            input.classList.add('active');
                        } else {
                            input.classList.remove('active');
                        }
                    });
                });

                // 宽高比选择框激活状态
                elements.aspectRatioSelect.addEventListener('change', () => {
                    elements.aspectRatioSelect.classList.add('active');
                });

                // 图片上传激活状态
                elements.imageUpload.addEventListener('change', () => {
                    const fileLabel = document.querySelector('.custom-file-upload');
                    if (elements.imageUpload.files.length > 0) {
                        fileLabel.classList.add('active');
                    } else {
                        fileLabel.classList.remove('active');
                    }
                });
            }

            // 设置导出按钮事件监听
            function setupExportListeners() {
                exportElements.pdfBtn.addEventListener('click', exportToPDF);
                exportElements.excelBtn.addEventListener('click', exportToExcel);
            }

            // 导出为 PDF
            async function exportToPDF() {
                const { jsPDF } = window.jspdf;
                
                // 显示加载中提示
                const loadingDiv = document.createElement('div');
                loadingDiv.style.position = 'fixed';
                loadingDiv.style.top = '0';
                loadingDiv.style.left = '0';
                loadingDiv.style.width = '100%';
                loadingDiv.style.height = '100%';
                loadingDiv.style.backgroundColor = 'rgba(0,0,0,0.7)';
                loadingDiv.style.zIndex = '9999';
                loadingDiv.style.display = 'flex';
                loadingDiv.style.justifyContent = 'center';
                loadingDiv.style.alignItems = 'center';
                loadingDiv.style.color = 'white';
                loadingDiv.style.fontSize = '24px';
                loadingDiv.innerHTML = '<div>正在生成PDF，请稍候...</div>';
                document.body.appendChild(loadingDiv);
                
                // 使用setTimeout让UI有时间更新
                setTimeout(async () => {
                    try {
                        // 改用竖向A4纸张
                        const doc = new jsPDF({
                            orientation: 'portrait',
                            unit: 'mm',
                            format: 'a4'
                        });
                        
                        // 获取A4纸张尺寸
                        const pageWidth = doc.internal.pageSize.getWidth();
                        const pageHeight = doc.internal.pageSize.getHeight();
                        
                        // 创建一个单独的大Canvas来绘制整个PDF内容
                        const mainCanvas = document.createElement('canvas');
                        const mainCtx = mainCanvas.getContext('2d');
                        // 创建一个足够大的画布以确保足够的分辨率
                        mainCanvas.width = 2480; // A4宽度@300dpi
                        mainCanvas.height = 3508; // A4高度@300dpi
                        
                        // 设置白色背景
                        mainCtx.fillStyle = 'white';
                        mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
                        
                        // 定义画布与PDF之间的缩放比例
                        const scaleRatio = mainCanvas.width / pageWidth;
                        
                        // 转换毫米到像素
                        function mmToPx(mm) {
                            return mm * scaleRatio;
                        }
                        
                        // ========== 绘制标题 ==========
                        mainCtx.font = 'bold 70px "Microsoft YaHei", SimHei, "Heiti SC"';
                        mainCtx.fillStyle = 'black';
                        mainCtx.textAlign = 'center';
                        mainCtx.textBaseline = 'top';
                        mainCtx.fillText("LED大屏模组布局方案", mainCanvas.width / 2, mmToPx(15));
                        
                        // ========== 绘制表格标题 ==========
                        mainCtx.font = 'bold 50px "Microsoft YaHei", SimHei, "Heiti SC"';
                        mainCtx.fillText("LED显示屏参数详情", mainCanvas.width / 2, mmToPx(35));
                        
                        // 获取当前参数
                        const moduleSize = elements.moduleSizeSelect.value.split('x');
                        const moduleWidth = parseFloat(moduleSize[0]);
                        const moduleHeight = parseFloat(moduleSize[1]);
                        const rows = parseInt(elements.rowsInput.value);
                        const cols = parseInt(elements.colsInput.value);
                        const pixelPitch = elements.pixelPitchSelect.value;
                        const totalWidth = (cols * moduleWidth / 1000).toFixed(2);
                        const totalHeight = (rows * moduleHeight / 1000).toFixed(2);
                        const totalArea = (totalWidth * totalHeight).toFixed(2);
                        const resolutionX = Math.floor(moduleWidth / pixelPitch) * cols;
                        const resolutionY = Math.floor(moduleHeight / pixelPitch) * rows;
                        const ratio = calculateClosestRatio(moduleWidth * cols, moduleHeight * rows);
                        
                        // 准备表格数据
                        const moduleResX = Math.floor(moduleWidth / pixelPitch);
                        const moduleResY = Math.floor(moduleHeight / pixelPitch);
                        
                        // 计算总分辨率
                        const totalResX = moduleResX * cols;
                        const totalResY = moduleResY * rows;
                        // 格式化总像素显示(转换为万为单位)
                        const totalPixels = totalResX * totalResY;
                        const totalPixelsInTenThousands = Math.round(totalPixels / 10000); // 四舍五入到万
                        const totalPixelsText = `${totalPixelsInTenThousands}万 px`;

                        // 更新表格数据结构 (添加单位)
                        const tableData = [
                            { label: "LED点间距", value: `P${pixelPitch} mm`, label2: "布局配置", value2: `${rows} 行 x ${cols} 列` },
                            { label: "模组尺寸", value: `${moduleSize.join(' x ')} mm`, label2: "模组分辨率", value2: `${moduleResX} x ${moduleResY} px` },
                            { label: "总宽度", value: `${totalWidth} m`, label2: "总高度", value2: `${totalHeight} m` },
                            { label: "分辨率", value: `${totalResX} x ${totalResY} px`, label2: "总像素", value2: totalPixelsText },
                            { label: "总面积", value: `${totalArea} ㎡`, label2: "屏幕比例", value2: `${ratio.name}` }
                        ];
                        
                        // 表格位置和尺寸
                        const tableTop = mmToPx(45);
                        const tableWidth = mmToPx(pageWidth - 20);
                        const cellHeight = 100; // 像素
                        const tableLeft = (mainCanvas.width - tableWidth) / 2;
                        
                        // 计算列宽度
                        const col1Width = tableWidth * 0.2;  // 第1列 - 标签
                        const col2Width = tableWidth * 0.3;  // 第2列 - 值
                        const col3Width = tableWidth * 0.2;  // 第3列 - 标签
                        const col4Width = tableWidth * 0.3;  // 第4列 - 值
                        
                        // 绘制表格
                        for (let i = 0; i < tableData.length; i++) {
                            const row = tableData[i];
                            const rowY = tableTop + (i * cellHeight);
                            
                            // 设置行背景色
                            mainCtx.fillStyle = i % 2 === 0 ? '#f0f0f0' : '#ffffff';
                            mainCtx.fillRect(tableLeft, rowY, tableWidth, cellHeight);
                            
                            // 绘制边框
                            mainCtx.strokeStyle = '#cccccc';
                            mainCtx.lineWidth = 2;
                            mainCtx.strokeRect(tableLeft, rowY, tableWidth, cellHeight);
                            
                            // 绘制分隔线
                            mainCtx.beginPath();
                            mainCtx.moveTo(tableLeft + col1Width, rowY);
                            mainCtx.lineTo(tableLeft + col1Width, rowY + cellHeight);
                            mainCtx.stroke();
                            
                            mainCtx.beginPath();
                            mainCtx.moveTo(tableLeft + col1Width + col2Width, rowY);
                            mainCtx.lineTo(tableLeft + col1Width + col2Width, rowY + cellHeight);
                            mainCtx.stroke();
                            
                            mainCtx.beginPath();
                            mainCtx.moveTo(tableLeft + col1Width + col2Width + col3Width, rowY);
                            mainCtx.lineTo(tableLeft + col1Width + col2Width + col3Width, rowY + cellHeight);
                            mainCtx.stroke();
                            
                            // 绘制文本
                            // 第1列 (左对齐)
                            mainCtx.fillStyle = 'black';
                            mainCtx.font = 'bold 35px "Microsoft YaHei", SimHei, "Heiti SC"';
                            mainCtx.textAlign = 'left';
                            mainCtx.textBaseline = 'middle';
                            mainCtx.fillText(row.label, tableLeft + 10, rowY + cellHeight / 2);
                            
                            // 第2列 (右对齐)
                            mainCtx.font = 'normal 35px "Microsoft YaHei", SimHei, "Heiti SC"';
                            mainCtx.textAlign = 'right';
                            mainCtx.fillText(row.value, tableLeft + col1Width + col2Width - 10, rowY + cellHeight / 2);
                            
                            // 第3列 (左对齐)
                            mainCtx.font = 'bold 35px "Microsoft YaHei", SimHei, "Heiti SC"';
                            mainCtx.textAlign = 'left';
                            mainCtx.fillText(row.label2, tableLeft + col1Width + col2Width + 10, rowY + cellHeight / 2);
                            
                            // 第4列 (右对齐)
                            mainCtx.font = 'normal 35px "Microsoft YaHei", SimHei, "Heiti SC"';
                            mainCtx.textAlign = 'right';
                            mainCtx.fillText(row.value2, tableLeft + tableWidth - 10, rowY + cellHeight / 2);
                        }
                        
                        // 计算表格总高度
                        const tableHeight = tableData.length * cellHeight;
                        
                        // ========== 绘制LED大屏图像 ==========
                        // 计算LED屏幕实际尺寸和位置
                        const screenWidth = cols * moduleWidth;
                        const screenHeight = rows * moduleHeight;
                        const screenRatio = screenWidth / screenHeight;
                        
                        // 创建临时画布来渲染LED屏幕
                        const screenCanvas = document.createElement('canvas');
                        const screenCtx = screenCanvas.getContext('2d');
                        
                        // 设置合适的尺寸以保持清晰度
                        const baseSize = 1000; // 基础尺寸
                        screenCanvas.width = screenRatio >= 1 ? baseSize : baseSize * screenRatio;
                        screenCanvas.height = screenRatio >= 1 ? baseSize / screenRatio : baseSize;
                        
                        // 计算模组尺寸
                        const moduleScaleWidth = screenCanvas.width / cols;
                        const moduleScaleHeight = screenCanvas.height / rows;
                        
                        // 绘制LED屏幕背景
                        screenCtx.fillStyle = '#f0f0f0';
                        screenCtx.fillRect(0, 0, screenCanvas.width, screenCanvas.height);

                        // 如果有上传的图片且处于显示状态，则绘制图片
                        if (uploadedImage && isImageVisible) {
                            screenCtx.drawImage(uploadedImage, 0, 0, screenCanvas.width, screenCanvas.height);
                        }

                        // 在屏幕图像上添加水印
                        screenCtx.save();
                        screenCtx.globalAlpha = 0.15; // 设置水印透明度
                        screenCtx.font = `${screenCanvas.width * 0.05}px "Microsoft YaHei"`; // 将字体大小系数从0.08改为0.05
                        screenCtx.fillStyle = '#000000';
                        screenCtx.textAlign = 'center';
                        screenCtx.textBaseline = 'middle';
                        
                        // 计算水印倾斜角度(15度)
                        screenCtx.translate(screenCanvas.width/2, screenCanvas.height/2);
                        screenCtx.rotate(-15 * Math.PI / 180);
                        screenCtx.fillText('禾禾慧能(北京)科技有限公司', 0, 0);
                        
                        // 恢复画布状态
                        screenCtx.restore();
                        
                        // 绘制模组网格 (移动到水印之后以保持网格清晰)
                        screenCtx.strokeStyle = uploadedImage && isImageVisible ? 'rgba(255,255,255,0.6)' : '#666666';
                        screenCtx.lineWidth = 1;
                        
                        for (let i = 0; i <= cols; i++) {
                            const x = i * moduleScaleWidth;
                            screenCtx.beginPath();
                            screenCtx.moveTo(x, 0);
                            screenCtx.lineTo(x, screenCtx.canvas.height);
                            screenCtx.stroke();
                        }
                        
                        for (let i = 0; i <= rows; i++) {
                            const y = i * moduleScaleHeight;
                            screenCtx.beginPath();
                            screenCtx.moveTo(0, y);
                            screenCtx.lineTo(screenCtx.canvas.width, y);
                            screenCtx.stroke();
                        }
                        
                        // 计算LED屏幕在PDF中的位置和尺寸
                        const imgY = tableTop + tableHeight + 200; // 增加了与表格的距离，从200改为300
                        const maxDrawWidth = mainCanvas.width - mmToPx(40);
                        const maxDrawHeight = mainCanvas.height - imgY - mmToPx(40);
                        
                        let drawWidth, drawHeight;
                        if (maxDrawWidth / screenRatio <= maxDrawHeight) {
                            drawWidth = maxDrawWidth * 0.9; // 减小宽度比例，从0.9改为0.85，给两侧留出更多空间
                            drawHeight = drawWidth / screenRatio;
                        } else {
                            drawHeight = maxDrawHeight * 0.9; // 减小高度比例
                            drawWidth = drawHeight * screenRatio;
                        }
                        
                        const imgLeft = (mainCanvas.width - drawWidth) / 2;
                        const borderWidth = Math.max(drawWidth * 0.01, 10);
                        const wallPadding = 100; // 增加墙面延伸范围，从100改为150

                        // 在绘制LED屏幕之前，先绘制墙面背景
                        const topSpace = 80; // 新增：屏幕顶部预留空间
                        const wallPattern = mainCtx.createPattern(createWallPattern(), 'repeat');
                        mainCtx.save();

                        // 绘制墙面（向下偏移topSpace）
                        mainCtx.fillStyle = wallPattern;
                        mainCtx.fillRect(
                            imgLeft - borderWidth - wallPadding,
                            imgY - borderWidth - topSpace,
                            drawWidth + (borderWidth + wallPadding) * 2,
                            drawHeight + borderWidth * 2 + wallPadding + topSpace
                        );

                        // 添加墙面阴影效果（同样向下偏移）
                        const wallGradient = mainCtx.createLinearGradient(
                            imgLeft - borderWidth - wallPadding,
                            imgY - borderWidth - topSpace,
                            imgLeft - borderWidth - wallPadding,
                            imgY + drawHeight + borderWidth * 2 + wallPadding
                        );

                        wallGradient.addColorStop(0, 'rgba(0,0,0,0.4)');
                        wallGradient.addColorStop(0.2, 'rgba(0,0,0,0.1)');
                        wallGradient.addColorStop(0.8, 'rgba(0,0,0,0.1)');
                        wallGradient.addColorStop(1, 'rgba(0,0,0,0.5)');
                        mainCtx.fillStyle = wallGradient;
                        mainCtx.fillRect(
                            imgLeft - borderWidth - wallPadding,
                            imgY - borderWidth - topSpace,
                            drawWidth + (borderWidth + wallPadding) * 2,
                            drawHeight + borderWidth * 2 + wallPadding + topSpace
                        );

                        mainCtx.restore();

                        // 添加黑色边框和阴影效果
                        mainCtx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                        mainCtx.shadowBlur = 20;
                        mainCtx.shadowOffsetX = 10;
                        mainCtx.shadowOffsetY = 10;

                        // 绘制外部黑色边框
                        mainCtx.fillStyle = '#000000';
                        mainCtx.fillRect(
                            imgLeft - borderWidth, 
                            imgY - borderWidth, 
                            drawWidth + borderWidth * 2, 
                            drawHeight + borderWidth * 2
                        );

                        // 重置阴影
                        mainCtx.shadowColor = 'transparent';
                        mainCtx.shadowBlur = 0;
                        mainCtx.shadowOffsetX = 0;
                        mainCtx.shadowOffsetY = 0;
                        
                        // 在主画布上绘制LED屏幕
                        mainCtx.drawImage(screenCanvas, imgLeft, imgY, drawWidth, drawHeight);
                        
                        // 添加边框装饰
                        mainCtx.strokeStyle = '#333333';
                        mainCtx.lineWidth = 2;
                        // 内边框
                        mainCtx.strokeRect(imgLeft, imgY, drawWidth, drawHeight);
                        // 外边框
                        mainCtx.strokeRect(
                            imgLeft - borderWidth, 
                            imgY - borderWidth, 
                            drawWidth + borderWidth * 2, 
                            drawHeight + borderWidth * 2
                        );

                        // 在边框角落添加装饰螺丝效果
                        const screwRadius = borderWidth * 0.3;
                        const screwPositions = [
                            [imgLeft - borderWidth/2, imgY - borderWidth/2],
                            [imgLeft + drawWidth + borderWidth/2, imgY - borderWidth/2],
                            [imgLeft - borderWidth/2, imgY + drawHeight + borderWidth/2],
                            [imgLeft + drawWidth + borderWidth/2, imgY + drawHeight + borderWidth/2]
                        ];

                        screwPositions.forEach(([x, y]) => {
                            mainCtx.beginPath();
                            mainCtx.arc(x, y, screwRadius, 0, Math.PI * 2);
                            mainCtx.fillStyle = '#4a4a4a';
                            mainCtx.fill();
                            mainCtx.strokeStyle = '#333333';
                            mainCtx.lineWidth = 1;
                            mainCtx.stroke();

                            // 添加螺丝纹理
                            mainCtx.beginPath();
                            mainCtx.moveTo(x - screwRadius/2, y);
                            mainCtx.lineTo(x + screwRadius/2, y);
                            mainCtx.moveTo(x, y - screwRadius/2);
                            mainCtx.lineTo(x, y + screwRadius/2);
                            mainCtx.strokeStyle = '#666666';
                            mainCtx.stroke();
                        });

                        // ========== 绘制页脚 ==========
                        const dateStr = new Date().toLocaleString();
                        mainCtx.font = 'italic 30px "Microsoft YaHei", SimHei, "Heiti SC"';
                        mainCtx.fillStyle = '#808080';
                        mainCtx.textAlign = 'center';
                        mainCtx.textBaseline = 'bottom';
                        mainCtx.fillText(`生成日期: ${dateStr} | LED大屏模组组装工具`, mainCanvas.width / 2, mainCanvas.height - 30);
                        
                        // ========== 将整个画布内容添加到PDF ==========
                        const finalImgData = mainCanvas.toDataURL('image/jpeg', 0.9);
                        doc.addImage(finalImgData, 'JPEG', 0, 0, pageWidth, pageHeight);
                        
                        // 保存文件
                        doc.save('LED大屏布局方案.pdf');
                        
                    } catch (error) {
                        console.error("PDF生成失败:", error);
                        alert("导出PDF时出错，请重试");
                    } finally {
                        // 移除加载提示
                        document.body.removeChild(loadingDiv);
                    }
                }, 100);
            }

            // 增加墙面图案生成函数
            function createWallPattern() {
                const patternCanvas = document.createElement('canvas');
                const patternCtx = patternCanvas.getContext('2d');
                const size = 40;
                patternCanvas.width = size;
                patternCanvas.height = size;

                // 设置背景色
                patternCtx.fillStyle = '#e6e6e6';
                patternCtx.fillRect(0, 0, size, size);

                // 绘制吸音板纹理
                patternCtx.strokeStyle = '#d9d9d9';
                patternCtx.lineWidth = 1;

                // 水平线
                for (let y = 0; y < size; y += 8) {
                    patternCtx.beginPath();
                    patternCtx.moveTo(0, y);
                    patternCtx.lineTo(size, y);
                    patternCtx.stroke();
                }

                // 垂直线
                for (let x = 0; x < size; x += 8) {
                    patternCtx.beginPath();
                    patternCtx.moveTo(x, 0);
                    patternCtx.lineTo(x, size);
                    patternCtx.stroke();
                }

                // 添加一些随机的小点表示质地
                patternCtx.fillStyle = '#cccccc';
                for (let i = 0; i < 10; i++) {
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    patternCtx.beginPath();
                    patternCtx.arc(x, y, 0.5, 0, Math.PI * 2);
                    patternCtx.fill();
                }

                return patternCanvas;
            }

            // 导出为 Excel
            function exportToExcel() {
                const wb = XLSX.utils.book_new();
                
                // 准备数据
                const moduleSize = elements.moduleSizeSelect.value.split('x');
                const moduleWidth = parseFloat(moduleSize[0]);
                const moduleHeight = parseFloat(moduleSize[1]);
                const rows = parseInt(elements.rowsInput.value);
                const cols = parseInt(elements.colsInput.value);
                const pixelPitch = elements.pixelPitchSelect.value;
                const totalWidth = (cols * moduleWidth / 1000).toFixed(2);
                const totalHeight = (rows * moduleHeight / 1000).toFixed(2);
                const totalArea = (totalWidth * totalHeight).toFixed(2);
                const resolutionX = Math.floor(moduleWidth / pixelPitch) * cols;
                const resolutionY = Math.floor(moduleHeight / pixelPitch) * rows;
                const ratio = calculateClosestRatio(moduleWidth * cols, moduleHeight * rows);

                // 计算模组分辨率
                const moduleResX = Math.floor(moduleWidth / pixelPitch);
                const moduleResY = Math.floor(moduleHeight / pixelPitch);
                
                // 计算总分辨率
                const totalResX = moduleResX * cols;
                const totalResY = moduleResY * rows;
                // 格式化总像素显示(转换为万为单位)
                const totalPixels = totalResX * totalResY;
                const totalPixelsInTenThousands = Math.round(totalPixels / 10000); // 四舍五入到万
                const totalPixelsText = `${totalPixelsInTenThousands}万 px`;

                // 创建数据数组
                const data = [
                    ['LED大屏模组布局方案'], 
                    [], 
                    ['LED显示屏参数详情'], 
                    [], 
                    ['参数', '值', '参数', '值'],
                    ['LED点间距', `P${pixelPitch} mm`, '布局配置', `${rows} 行 x ${cols} 列`],
                    ['模组尺寸', `${moduleSize.join(' x ')} mm`, '模组分辨率', `${moduleResX} x ${moduleResY} px`],
                    ['总宽度', `${totalWidth} m`, '总高度', `${totalHeight} m`],
                    ['分辨率', `${totalResX} x ${totalResY} px`, '总像素', totalPixelsText],
                    ['总面积', `${totalArea} ㎡`, '屏幕比例', `${ratio.name}`]
                ];

                // 创建工作表
                const ws = XLSX.utils.aoa_to_sheet(data);

                // 设置单元格合并
                ws['!merges'] = [
                    { s: { r: 0, c: 0 }, e: { r: 0, c: 3 } }, // 合并标题行
                    { s: { r: 2, c: 0 }, e: { r: 2, c: 3 } }  // 合并参数详情行
                ];

                // 设置列宽
                ws['!cols'] = [
                    { wch: 12 }, // A列宽
                    { wch: 18 }, // B列宽
                    { wch: 12 }, // C列宽
                    { wch: 18 }  // D列宽
                ];

                // 设置表格样式和边框
                const range = { s: { r: 0, c: 0 }, e: { r: 8, c: 3 } };  // 扩展范围包括所有单元格
                for (let R = range.s.r; R <= range.e.r; R++) {
                    for (let C = range.s.c; C <= range.e.c; C++) {
                        const cell_ref = XLSX.utils.encode_cell({ r: R, c: C });
                        if (!ws[cell_ref]) {
                            ws[cell_ref] = { v: '', t: 's' };
                        }
                        
                        // 为所有单元格(包括空行和标题)添加边框
                        if (!ws[cell_ref].s) ws[cell_ref].s = {};
                        ws[cell_ref].s = {
                            ...ws[cell_ref].s,
                            border: {
                                top: { style: 'thin', color: { rgb: "000000" } },
                                bottom: { style: 'thin', color: { rgb: "000000" } },
                                left: { style: 'thin', color: { rgb: "000000" } },
                                right: { style: 'thin', color: { rgb: "000000" } }
                            }
                        };

                        // 设置对齐方式
                        ws[cell_ref].s.alignment = {
                            vertical: 'center',
                            horizontal: (R <= 2) ? 'center' : (C % 2 ? 'right' : 'left')
                        };

                        // 参数列加粗 (第5行开始的第1、3列)
                        if (R >= 4 && (C === 0 || C === 2)) {
                            ws[cell_ref].s.font = { bold: true };
                        }
                    }
                }

                // 更新标题样式但保持边框
                if (ws['A1']) {
                    ws['A1'].s = {
                        ...ws['A1'].s,
                        fill: { fgColor: { rgb: "C4BD97" } },
                        font: { sz: 14, bold: true }
                    };
                }

                if (ws['A3']) {
                    ws['A3'].s = {
                        ...ws['A3'].s,
                        fill: { fgColor: { rgb: "E9EDF7" } },
                        font: { bold: true }
                    };
                }

                // 添加工作表到工作簿并保存
                XLSX.utils.book_append_sheet(wb, ws, "布局方案");
                XLSX.writeFile(wb, 'LED大屏布局方案.xlsx');
            }

            // 更新模组尺寸选项
            function updateModuleSizeOptions() {
                const pitchToSizeMap = {
                    "1.25": ["300x337.5", "320x160"],
                    "1.53": ["320x160"],
                    "1.66": ["320x160"],
                    "1.8": ["320x160", "304x168.5"],
                    "2": ["320x160", "304x168.5"],
                    "2.5": ["320x160", "304x168.5"],
                    "3": ["256x128", "192x192"],
                    "4": ["256x128", "192x192"]
                };
                const selectedPitch = elements.pixelPitchSelect.value;
                const availableSizes = pitchToSizeMap[selectedPitch];
                elements.moduleSizeSelect.innerHTML = '';
                availableSizes.forEach(size => {
                    const option = document.createElement('option');
                    option.value = size;
                    option.textContent = size.replace('x', ' x ');
                    elements.moduleSizeSelect.appendChild(option);
                });
                elements.generateBtn.disabled = false;
            }

            // 切换计算模式
            function switchMode(event) {
                elements.modeButtons.forEach(btn => btn.classList.remove('active'));
                event.target.classList.add('active');
                currentMode = event.target.getAttribute('data-mode');
                document.querySelectorAll('.input-group').forEach(group => group.style.display = 'none');
                document.getElementById(currentMode + 'Input').style.display = 'flex';
                elements.generateBtn.disabled = false;
                saveConfig();
            }

            // 调整画布大小
            function resizeCanvas(width, height) {
                elements.canvas.width = width;
                elements.canvas.height = height;
                elements.canvas.style.width = `${width}px`;
                elements.canvas.style.height = `${height}px`;
            }

            // 绘制欢迎屏幕
            function drawWelcomeScreen() {
                // 填充整个画布
                const containerWidth = elements.canvasContainer.clientWidth;
                const containerHeight = elements.canvasContainer.clientHeight;
                resizeCanvas(containerWidth, containerHeight);
                
                ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
                const gradient = ctx.createLinearGradient(0, 0, elements.canvas.width, elements.canvas.height);
                gradient.addColorStop(0, '#76b900');
                gradient.addColorStop(0.3, '#000000');
                gradient.addColorStop(0.55, '#76b900');
                gradient.addColorStop(1, '#000000');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, elements.canvas.width, elements.canvas.height);
                
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = 'bold 36px Segoe UI';
                ctx.fillText('欢迎使用大屏模组组装工具', elements.canvas.width / 2, elements.canvas.height / 2 - 20);
                ctx.font = '18px Segoe UI';
                ctx.fillText('点击"生成布局"开始设计您的大屏', elements.canvas.width / 2, elements.canvas.height / 2 + 30);
            }

            // 获取宽高比
            function getAspectRatio() {
                let ratioStr = elements.aspectRatioSelect.value;
                const ratioMatch = ratioStr.match(/^(\d+(\.\d+)?):(\d+(\.\d+)?)$/);
                if (!ratioMatch) {
                    alert('宽高比格式错误，请输入如 "16:9" 或 "2:1" 的格式');
                    return null;
                }
                const ratioX = parseFloat(ratioMatch[1]);
                const ratioY = parseFloat(ratioMatch[3]);
                if (ratioX <= 0 || ratioY <= 0) {
                    alert('宽高比必须大于0');
                    return null;
                }
                return { ratioX, ratioY };
            }

            // 添加宽高联动计算函数
            function setupDimensionLinkage() {
                const totalWidthInput = elements.totalWidthInput;
                const totalHeightInput = elements.totalHeightInput;
                const aspectRatioSelect = elements.aspectRatioSelect;

                function calculateDimension(sourceInput, targetInput, isWidth) {
                    const ratio = getAspectRatio();
                    if (!ratio) return;
                    
                    const sourceValue = parseFloat(sourceInput.value);
                    if (isNaN(sourceValue) || sourceValue <= 0) return;

                    let newValue;
                    if (isWidth) {
                        newValue = sourceValue * ratio.ratioY / ratio.ratioX;
                    } else {
                        newValue = sourceValue * ratio.ratioX / ratio.ratioY;
                    }
                    targetInput.value = newValue.toFixed(2);
                }

                totalWidthInput.addEventListener('input', () => {
                    if (currentMode === 'dimension') {
                        calculateDimension(totalWidthInput, totalHeightInput, true);
                    }
                });

                totalHeightInput.addEventListener('input', () => {
                    if (currentMode === 'dimension') {
                        calculateDimension(totalHeightInput, totalWidthInput, false);
                    }
                });

                aspectRatioSelect.addEventListener('change', () => {
                    if (currentMode === 'dimension') {
                        calculateDimension(totalWidthInput, totalHeightInput, true);
                    }
                });
            }

            // 添加比例计算函数
            function calculateClosestRatio(width, height) {
                const commonRatios = [
                    { name: '16:9', value: 16/9 },
                    { name: '16:10', value: 16/10 },
                    { name: '4:3', value: 4/3 },
                    { name: '3:2', value: 3/2 },
                    { name: '21:9', value: 21/9 },
                    { name: '1:1', value: 1 },
                    { name: '9:16', value: 9/16 },
                    { name: '16:8', value: 16/8 },
                    { name: '32:9', value: 32/9 },
                    { name: '5:4', value: 5/4 }
                ];

                const actualRatio = width / height;
                let closest = commonRatios[0];
                let minDiff = Math.abs(actualRatio - closest.value);

                for (let ratio of commonRatios) {
                    const diff = Math.abs(actualRatio - ratio.value);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closest = ratio;
                    }
                }

                return closest;
            }

            // 修改更新维度信息的函数
            function updateDimensionInfo(moduleWidth, moduleHeight, rows, cols) {
                const totalWidth = cols * moduleWidth;
                const totalHeight = rows * moduleHeight;
                const totalWidthMeters = (totalWidth / 1000).toFixed(2);
                const totalHeightMeters = (totalHeight / 1000).toFixed(2);
                const totalAreaMeters = ((totalWidth * totalHeight) / 1000000).toFixed(2);
                const pixelPitch = elements.pixelPitchSelect.value;
                const resolutionX = Math.floor(moduleWidth / pixelPitch) * cols;
                const resolutionY = Math.floor(moduleHeight / pixelPitch) * rows;
                const screenRatio = (totalWidth / totalHeight).toFixed(2);
                
                // 计算最接近的比例（对所有模式都生效）
                const ratio = calculateClosestRatio(totalWidth, totalHeight);
                const closestRatio = ` (最接近 ${ratio.name})`;

                elements.dimensionInfo.innerHTML = `大屏数据: 宽度 <span class="dimension-highlight">${totalWidthMeters} m</span>, 高度 <span class="dimension-highlight">${totalHeightMeters} m</span>, 面积 <span class="dimension-highlight">${totalAreaMeters} ㎡</span> | 布局: <span class="dimension-highlight">${rows}行 x ${cols}列</span> | 点间距: <span class="dimension-highlight">P${pixelPitch}</span> | 分辨率: <span class="dimension-highlight">${resolutionX} x ${resolutionY}</span> | 屏幕比例: <span class="dimension-highlight">${screenRatio}:1${closestRatio}</span>`;
            }

            // 生成布局
            function generateLayout() {
                let moduleSize = elements.moduleSizeSelect.value.split('x');
                let moduleWidth = parseFloat(moduleSize[0]);
                let moduleHeight = parseFloat(moduleSize[1]);
                let rows, cols;

                if (currentMode === 'manual') {
                    rows = parseInt(elements.rowsInput.value);
                    cols = parseInt(elements.colsInput.value);
                    if (rows < 1 || cols < 1) {
                        alert('行数和列数必须大于0');
                        return;
                    }
                } else if (currentMode === 'dimension') {
                    const totalWidth = parseFloat(elements.totalWidthInput.value) * 1000;
                    const totalHeight = parseFloat(elements.totalHeightInput.value) * 1000;
                    if (totalWidth <= 0 || totalHeight <= 0) {
                        alert('宽度和高度必须大于0');
                        return;
                    }
                    rows = Math.round(totalHeight / moduleHeight);
                    cols = Math.round(totalWidth / moduleWidth);
                } else if (currentMode === 'ratio') {
                    const totalWidth = parseFloat(elements.ratioWidthInput.value) * 1000;
                    const totalHeight = parseFloat(elements.ratioHeightInput.value) * 1000;
                    if (totalWidth <= 0 || totalHeight <= 0) {
                        alert('宽度和高度必须大于0');
                        return;
                    }
                    rows = Math.round(totalHeight / moduleHeight);
                    cols = Math.round(totalWidth / moduleWidth);
                }

                elements.rowsInput.value = rows;
                elements.colsInput.value = cols;

                const containerWidth = elements.canvasContainer.clientWidth - 40;
                const containerHeight = Math.max(500, elements.canvasContainer.clientHeight) - 40;
                let totalWidth = cols * moduleWidth + (cols - 1) * 2;
                let totalHeight = rows * moduleHeight + (rows - 1) * 2;
                let scaleX = containerWidth / totalWidth;
                let scaleY = containerHeight / totalHeight;
                let scale = Math.min(scaleX, scaleY, 1);
                resizeCanvas(containerWidth, containerHeight);
                drawModules(moduleWidth, moduleHeight, rows, cols, scale);
                elements.generateBtn.disabled = true;
                isInitialState = false;
                saveConfig();
            }

            // 绘制模组布局
            function drawModules(moduleWidth, moduleHeight, rows, cols, scale) {
                ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
                const gap = 2 * scale;
                const scaledModuleWidth = moduleWidth * scale;
                const scaledModuleHeight = moduleHeight * scale;
                const totalLayoutWidth = cols * scaledModuleWidth + (cols - 1) * gap;
                const totalLayoutHeight = rows * scaledModuleHeight + (rows - 1) * gap;
                const startX = (elements.canvas.width - totalLayoutWidth) / 2;
                const startY = (elements.canvas.height - totalLayoutHeight) / 2;

                if (uploadedImage && isImageVisible) {
                    ctx.drawImage(uploadedImage, startX, startY, totalLayoutWidth, totalLayoutHeight);
                    // 分析图片颜色
                    let imgData;
                    try {
                        imgData = ctx.getImageData(startX, startY, totalLayoutWidth, totalLayoutHeight);
                        let brightness = 0;
                        let pixels = 0;
                        
                        // 采样计算图片整体亮度
                        for (let i = 0; i < imgData.data.length; i += 16) {
                            brightness += (imgData.data[i] + imgData.data[i + 1] + imgData.data[i + 2]) / 3;
                            pixels++;
                        }
                        
                        brightness = brightness / pixels;
                        // 根据亮度选择分割线颜色
                        ctx.strokeStyle = brightness > 128 ? 'rgba(80, 80, 80, 0.6)' : 'rgba(255, 255, 255, 0.6)';
                    } catch (e) {
                        // 如果无法获取图片数据（比如跨域图片），使用默认的灰色
                        ctx.strokeStyle = 'rgba(80, 80, 80, 0.6)';
                    }
                } else {
                    // 无图片时使用细灰色线
                    ctx.strokeStyle = 'rgba(180, 180, 180, 0.8)';
                }

                // 设置更细的线条
                ctx.lineWidth = 0.5;

                // 绘制模组边框
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        let x = startX + j * (scaledModuleWidth + gap);
                        let y = startY + i * (scaledModuleHeight + gap);
                        ctx.strokeRect(x, y, scaledModuleWidth, scaledModuleHeight);
                    }
                }

                updateDimensionInfo(moduleWidth, moduleHeight, rows, cols);
            }

            // 处理图片上传
            function handleImageUpload(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.onload = function() {
                            uploadedImage = img;
                            elements.imagePreviewStatus.textContent = `已选择图片: ${file.name}`;
                            elements.toggleImageBtn.disabled = false;
                            elements.clearImageBtn.disabled = false;
                            isImageVisible = true;
                            elements.toggleImageBtn.textContent = '隐藏图片预览';
                            if (!isInitialState) {
                                generateLayout();
                            }
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            }

            // 切换图片显示状态
            function toggleImageVisibility() {
                isImageVisible = !isImageVisible;
                elements.toggleImageBtn.textContent = isImageVisible ? '隐藏图片预览' : '显示图片预览';
                if (!isInitialState) {
                    generateLayout();
                }
            }

            // 清除图片
            function clearImage() {
                uploadedImage = null;
                isImageVisible = false;
                elements.imagePreviewStatus.textContent = '未选择图片';
                elements.toggleImageBtn.disabled = true;
                elements.clearImageBtn.disabled = true;
                elements.toggleImageBtn.textContent = '显示图片预览';
                elements.imageUpload.value = '';
                document.querySelector('.custom-file-upload').classList.remove('active');
                if (!isInitialState) {
                    generateLayout();
                }
            }

            // 重置画布
            function resetCanvas() {
                ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
                resizeCanvas(800, 500);
                elements.dimensionInfo.innerHTML = '大屏数据将会显示在这里';
                elements.rowsInput.value = 2;
                elements.colsInput.value = 2;
                elements.pixelPitchSelect.value = '1.25';
                const event = new Event('change');
                elements.pixelPitchSelect.dispatchEvent(event);
                elements.generateBtn.disabled = false;
                isInitialState = true;
                currentMode = 'manual';
                elements.modeButtons.forEach(btn => btn.classList.remove('active'));
                elements.modeButtons[0].classList.add('active');
                document.querySelectorAll('.input-group').forEach(group => group.style.display = 'none');
                document.getElementById('manualInput').style.display = 'flex';
                elements.aspectRatioSelect.value = '16:9';
                elements.totalWidthInput.value = 0;
                elements.totalHeightInput.value = 0;
                elements.totalWidthInput.classList.remove('active');
                elements.totalHeightInput.classList.remove('active');
                elements.aspectRatioSelect.classList.remove('active');
                document.querySelector('.custom-file-upload').classList.remove('active');
                drawWelcomeScreen();
                localStorage.removeItem('ledScreenConfig');
                clearImage();
            }

            // 返回公共方法
            return {
                init: init
            };
        })();

        // 初始化应用
        window.onload = App.init;
    </script>
</body>
</html>
